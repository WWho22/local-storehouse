# C语言

## 知识点

### vs2022如何执行代码：

ctrl+f5 

main函数是程序的入口

### 计算机中的单位：

bit - 比特位
byte - 字节    1 byte = 8 bit 
kb    1024
mb    1024
gb    1024
tb    1024
pb    1024


char  -1字节
short -2字节
int   -4字节
float -4字节
long  -4字节
long long -8字节
double -8字节

### 变量和常量的概念

变量分为：
局部变量 - main()函数内部定义的变量
全局变量 - main()函数外部定义的变量
在相同函数范围内，不能重定义变量，但当全局变量和局部变量名字相同的情况下，局部优先



```c
int main()
{
	printf("hehe\n");
	printf("%zu\n",sizeof(char));

	return 0;

}
```

a++是a+1以前的值
++a是a+1以后的值

### 运算符 

相等 ==
不相等 ！=
大于或等于 >=
小于或等于 <=

当两个值的关系符合关系运算的预期时,关系运算的结果为整数1,否则为整数0
5==3 5>3 5<=3

### 优先级

- 所有的关系运算符的优先级比算术运算的低,但是比赋值运算的高
- 判断是否相等的==和!=的优先级比其他的低,而连续的关系运算是从左到右进行的,例如:6>5>4 output=1
- a==b==6 先看a是否等于b,然后看其结果与6是否相等

![image-20240922155109492](C语言.assets/image-20240922155109492.png)

### switch语句

- 可以看作是基于计算的跳转,计算表达式的值以后,程序会跳到相匹配的case处
- 在执行完分支中的最后一条语句后,如果后面没有break,就会顺序执行到下面的case里,直至遇到break或者程序结束

### do-while

do-while与while的区别是do-while是无论如何先执行一次,然后再判断条件,while是先判断条件再执行循环体的内容

### break

break只能跳出当前循环层的语句，当遇到嵌套循环想要一次性跳出所有循环，使用goto out; out:，out:指引跳到其所在的语句

### 进制

- 以0开头的数字字面是八进制，以0x开头的是十六进制
- inf、-inf分别表示正负无穷，nan表示非有效数字即不存在
  %e是科学计数法的表示，1.39882 e-10
- 带小数点的数字面量是double而非float
- float需要用f或者F后缀来表明身份

### 逃逸字符

  \是逃逸字符，与其他符号组合表示不同意义，如\"表示双引号，因为单独的"在代码中不会被表示为双引号
 scanf中必须要写各自类型对应的代指符，如int必须对应%d，short必须对应%hd

![image-20240922155049769](C语言.assets/image-20240922155049769.png)

### 强制类型转换

- 强制类型转换的优先级高于四则运算,(int)a/b，是先把a强制转换再除以b

- 包含头文件<stdbool.h>可以使用bool类型变量true和false，其最终输出分别是1和0，并且只能按照整数输出
- 逻辑运算符优先级:! > && > ||

### 函数

- void后面整行为函数头，分别为返回类型，函数名，参数表，大括号及其内容为函数体
  调用函数:sum(1,2)
- 函数的返回最好遵循单一出口，即只有一个return语句，且return语句停止函数的执行，并返回一个值

- 无返回值的函数void function(参数表)，不能使用带值的return，可以没有return语句，调用时不能做返回值的赋值

- 一般来说，函数定义应该放在main()函数之前，但是如果想要把函数定义放在main()后面仍然能编译使用

- 需要在main()之前加上函数头与分号;，这是在main()前声明该函数的类型与定义

- 函数原型:函数头以分号;结尾，构成了函数头


![image-20240922155122813](C语言.assets/image-20240922155122813.png)

### 变量

- 每个函数都有自己的变量空间，参数也位于这个独立的空间中，和其他函数没有关系

- 定义在函数内部的变量称为本地变量，，参数也是本地变量，变量的生存期与作用域都在大括号内---块

- 程序在运行到这个块之前，其中的变量不存在，离开这个块，其他的变量就消失了

- 块外面定义的变量在块里边仍然有效，块里边定义的变量与外面重名时，则掩盖了外面的变量的值

- 不能在同一个块里重定义变量，本地变量不会被默认初始化


![image-20240922155144523](C语言.assets/image-20240922155144523.png)

#### 静态变量

[关键字static修饰局部变量、全局变量和函数详解](https://blog.csdn.net/2302_76305195/article/details/132035585?ops_request_misc=%257B%2522request%255Fid%2522%253A%252269d4e88da6ba1150a286097903378906%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=69d4e88da6ba1150a286097903378906&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-132035585-null-null.142^v101^pc_search_result_base5&utm_term=%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F&spm=1018.2226.3001.4187)

static用于修饰变量和函数。static修饰局部变量称为静态局部变量，static修饰全局变量称为静态全局变量，static修饰函数称为静态函数。

- static修饰全局变量，静态全局变量只能在自身所在的源文件被使用
- static修饰局部变量，静态局部变量在程序执行到该对象的声明处时被首次初始化，**即以后的函数调用不再将该变量进行初始化，相当于保留该变量在函数执行结束时的值**。具体原理在上述超链接中。
- static修饰函数，静态函数只能在声明它的文件当中可见，不能被其他文件使用（同static修饰全局变量一样）。

### 数组

#### 数组是一种容器，特点是：

- 其中所有的元素都具有相同的数据类型；
- 一旦创建，不能改变数组的长度；
- 数组中的元素在内存中是连续依次排列的
- 数组中的每个单元都是数组类型的一个变量
- 使用数组时，放在[]内的数字叫做下标或者索引，下标从0开始计数
- 使用数组时要把数组内元素初始化

#### 数组的大小

- sizeof给出整个数组所占据的内容的大小，单位是字节,定义数组a[]，sizeof(a)/sizeof(a[0])
- sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组单元的个数
- 这样的代码，一旦修改数组中初始的数据，不需要修改遍历的代码

#### 数组的赋值

- 数组变量本身不能被赋值，即

  ```c
  int a[]={1,2,3,5};
  int b[];
  a=b;//这样做是不允许的，数组变量之间不能相互赋值
  ```
- ```c
  int b[] --> int *const b;
  //b此时被const修饰，即常数变量，不能直接被赋值，即b不能被赋成其他的数组，否则b的地址就被更改了
  ```

- 要把一个数组的变量的所有元素交给另一个数组，必须采用遍历

#### 数组作为函数的参数时

- 数组作为函数参数时，往往必须再用另一个参数来传入数组的大小
- 不能在[]中给出数组的大小
- 不能再利用sizeof来计算数组的元素个数

![image-20240922223544364](C语言.assets/image-20240922223544364.png)

### 二维数组

```c
int a[3][5];
```

通常理解为a是一个三行五列的矩阵

![image-20240923230406748](C语言.assets/image-20240923230406748.png)

```c
a[i][j]是一个int，表示第i行第j列上的单元
```

#### 二维数组的初始化

- 列数是必须给出的，行数可以由编译器来数
- 每行一个{}，逗号分隔
- 如果省略，表示补0

![image-20240923231423134](C语言.assets/image-20240923231423134.png)

### 指针

#### 运算符&

- 它的作用是获得变量的地址(首地址)，它的操作数必须是变量

- 并且在printf()中输出地址需要使用%p，

  ```c
  int i;
  printf("%p",&i);
  ```

  

- 地址的大小是否与int相同取决于编译器

- &也是引用符，

#### 指针变量

- 就是保存地址的变量

- 

  ```c
  int* p = &i(此时p变量里边存储的是i的首地址)
  int* p,q (1)
  int *p,q (2)
  (1)和(2)的意思都是p为指针变量，q为整型变量，*靠近p或者远离p都不会改变p是指针变量的事实
  ```

- 变量的值是内存的地址

- 普通变量的值是实际的值，指针变量的值是具有实际值的变量的地址

- ![image-20240924001136215](C语言.assets/image-20240924001136215.png)

![image-20240924001200881](C语言.assets/image-20240924001200881.png)

#### 作为参数的指针

- void f(int *p)

- 在被调用的时候获得了某个变量的地址

- ```c
  int i = 0;
  f(&i);
  ```

- p得到了i的地址，在函数里面可以通过这个指针访问外面的这个i

#### 访问那个地址上的变量*

- *是一个单目运算符，用来访问指针的值所表示的地址上的变量

- 可以做右值也可以做左值

- ```c
  int k = *p;//做右值是将p指向的变量的值赋值给k
  *p = k+1;//做左值是将p指向的变量内的值修改为k+1
  ```

  ![image-20240924002626773](C语言.assets/image-20240924002626773.png)

![image-20240923203524017](C语言.assets/image-20240923203524017.png)

#### 函数应用场景

![image-20240926153531855](C语言.assets/image-20240926153531855.png)

- 函数返回多个值，某些值就只能通过指针返回，比如int类型的函数用return返回就只能返回一个数字
- 传入的参数实际上是需要保存带回结果的变量，比如最终结果输出为1，同时也要返回状态是否正常来打印。即直接把状态写入指针指向的对象，把函数状态带回主函数的变量。

#### 指针最常见的错误

- 定义了指针变量，还没有指向任何变量，就开始使用指针

#### 函数传入的参数

- 函数传入参数中含有数组的话，在调用函数时，只需填写对应数组的数组名即可

- 数组参数，以下四种函数原型的等价的：

  - ```c
    int sum(int *ar,int n);
    ```

  - ```c
    int sum(int *,int);
    ```

  - ```c
    int sum(int ar[],int n);
    ```

  - ```c
    int sum(int [],int);
    ```

数组参数在函数参数定义中，即可用作数组变量，也可以用作指针变量，即ar[] ==  *a。在函数中，当你将主函数中的数组名ar传入函数以后，此时定义的指针变量a里边存储的是ar[0]元素的地址，则 *a == ar[0]实际上都指向同一个值。因此当你现在写入 *a = 1，在主函数读出来的ar[0]也等于1；反过来，a[]在函数中也可以当作指针与数组。

#### 指针变量是特殊的指针

- 数组变量本身表达地址，所以

  - ```c
    int a[10];int *p=a;//无需用&取地址
    ```

  - 但是数组的单元表达的是变量，需要用&取地址

  - a == &a[0]

- []运算符可以对数组做，也可以对指针做：

  - ```c
    int *p = &min; 
    printf("*p = %d",*p);
    printf("p[0] = %d",p[0]);
    //输出结果即*p == p[0]，即指针变量存储的地址等于其同名数组的首元素的地址
    ```

- *运算符可以对指针做，也可以对数组做

  - ```c
    int a[];
    *a = 25;//此时a[0]=25
    ```

#### 指针与const

- 指针是const，表示一旦得到了某个变量的地址，不能再指向其他变量。即const修饰的是p，p里边存放的地址不能修改。

  - ```c
    int *const q = &i;//q是const,即q的值不能改变
    ```

  - ```c
    *q = 26;//OK
    ```

  - ```c
    q++;//ERROR
    ```

- 所指是const，表示不能通过这个指针去修改那个变量（并不能使得那个变量成为const）。即const修饰的是*p， *p不能被修改。

  - ```c
    const int *p = &i;
    ```

  - ```c
    *p = 26;//ERROR!(*p)是const
    ```

  - ```c
    i=26;//OK
    ```

  - ```c
    p = &j;//OK
    ```

  ![image-20240926192958594](C语言.assets/image-20240926192958594.png)

#### 指针运算

- 给一个指针加一表示要让指针指向下一个变量

  - ```c
    int a[10];
    int *p = a;
    *(p+1)= a[1];
    ```

- 如果指针不是指向一片连续分配的空间，如数组，则这种运算没有意义

- 指针运算，这些算术运算可以对指针做：

  - 给指针加、减一个整数（+，+=，-，-=）

  - 递增递减（++/--）

  - 两个指针相减，即:

  - ```c
    char ac[] = {0，1，2，3，4，5};
    char *p = &ac[0];
    char *p1 = &a[5];
    printf("p1-p=%d",p1-p);//结果为5
    
    char ar[] = {0，1，2，3，4，5};
    char *q = &ar[0];
    char *q1 = &ar[6];
    printf("q1-q=%d",q1-q);//结果为6,实际上在工作台返回的地址值两个相减是0x18，转为十进制为24，即六个int类型数的大小。所以指针相减返回的值为地址相减/sizeof（类型）
    ```

- *p++：

  - 取出p所指的那个数据来，完事之后顺便把p移到下一个位置去
  - *的优先级虽然高，但是没有++高
  - 常用于数组类的连续空间操作
  - ![image-20240926214554055](C语言.assets/image-20240926214554055.png)

#### 指针比较

- <,<=,==,>,>=,!=都可以对指针做
- 比较他们在内存中的地址
- 数组中的单元的地址肯定是线性递增的

#### 指针的类型

- 无论指向什么类型，所有指针的大小都是一样的，因为都是地址
- 但是指向不同类型的指针是不能直接相互赋值的
- 这是为了避免用错指针

#### 指针的类型转换

- void*表示不知道指向什么东西的指针
  - 计算时与char*相同（但不相通）
- 指针也可以转换类型
  - int *p = &i;void *q = (void *)p;
- 这并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看它所指的变量

#### 如何判断指针数组、数组指针

从字面意思去理解：数组指针和指针数组，只要在名词的中间加上“的”字，就能明显区分：

- 数组的指针：是一个指针，指向数组的指针
- 指针的数组：是一个数组，装着指针的数组

从符号方面去理解：

首先需要明确一个优先级顺序：()>[]>*

- (*p)[]：根据优先级，先看括号内，则p是一个指针，这个指针指向一个一维数组，数组长度为n，这是“数组的指针”，即数组指针；
- p[]：根据优先级，先看[]，则p是一个数组，再结合，这个数组的元素是指针类型，共n个元素，这是“指针的数组”，即指针数组。

[指针进阶：数组指针、指针数组、字符指针（超详细讲解，小白一看就懂!!!!!!）_字符串指针前两个指针符号是啥疑似-CSDN博客](https://blog.csdn.net/weixin_45031801/article/details/127381406?ops_request_misc=%7B%22request%5Fid%22%3A%22F17FDAB2-A0D4-4D79-8A57-E54C6A54F697%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=F17FDAB2-A0D4-4D79-8A57-E54C6A54F697&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-127381406-null-null.142^v100^control&utm_term=数组指针&spm=1018.2226.3001.4187)

### 字符串

### 动态内存分配

#### 输入数据

- 如果输入数据时，先告诉你个数，然后再输入，要记录每个数据

- C99可以用变量做数组定义的大小，C99之前呢？

- ```c
   int *a =(int *)malloc(n * sizeof(int)); 
  //malloc()为申请内存的函数，函数参数为申请n个int类型字节大小的空间，并且要有类型转换为对应的类型空间，使用该函数前要包含<stdlib.h>头文件
  ```

![image-20240927103355080](C语言.assets/image-20240927103355080.png)

#### malloc

```c
#include<stdlib.h>
void* malloc(size_t size)
```

- 向malloc申请的空间的大小是以字节为单位的

- 返回的结果是void*，需要类型转换为自己需要的类型

  - ```c
    (int*)malloc(n*sizeof(int))
    ```

#### 没空间了？

- 如果申请失败则返回0，或者叫做NULL

#### free()

- 把申请得来的空间还给“系统”
- 申请过的空间最终都应该要
- 只能还申请来的空间的首地址

#### 常见问题

- 申请了没free-->长时间运行内存逐渐下降
  - 新手：忘了
  - 老手：找不到合适的free时机
- free过了再free
- 地址变过了，直接去free

### const

#### const数组

- ```c
  const int a[]={1,2,3,4,5,6};
  ```

- 数组变量已经是const的指针了，这里的const表明数组的每个单元都是const int，每个单元都不能修改；

- 所以必须通过初始化赋值

##### 保护数组值

- 因为把数组传入参数时传递的时地址，所以那个函数内部可以修改数组的值；

- 为了保护数组不被函数破坏，可以设置参数为const；

- ```c
  int sum(const int a[],int length);
  ```


### 字符串

- C语言的字符串是以字符数组的形态存在的
  - 不能用运算符对字符串做运算
  - 通过数组的方式可以遍历字符串

#### 字符数组结构

![image-20240927163658220](C语言.assets/image-20240927163658220.png)

#### 字符串结构

![image-20240927163831259](C语言.assets/image-20240927163831259.png)

- 以0（整数0）结尾的一串字符
  - 0或‘\0’是一样的，但是和‘0’不同，后者为字符0
- 0标志字符串的结束，但它不是字符串的一部分
  - 计算字符串长度的时候不包括这个0
- 字符串以数组的形式存在，以数组或指针的形式访问
  - 更多的是以指针的形式
- string.h里有很多处理字符串的函数

#### 字符串变量

- ```c
  char *str = "Hello";
  ```

- ```c
  char word[]="Hello";
  ```

- ```c
  char line[10] = "Hello";
  ```

#### 字符串常量

- ”Hello“
- "Hello"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0
- 两个相邻的字符串常量会被自动连接起来
- ![image-20240927170417219](C语言.assets/image-20240927170417219.png)

```c
char* s = "Hello,world!";
```

- s是一个指针，初始化指向一个字符串常量

  - 由于这个常量所在的地方叫做代码段，是只读的，所以实际上s是const char *s，但是由于历史的原因，编译器接受不带const的写法，即 *s的内容无法被修改
  - 试图对s所指的字符串做写入会导致严重的后果，并且如果两个字符指针都指向同一个字符串，指针存储的地址是相同的
  - 引入字符数组来存储信息，其实是在代码段把对应的信息复制一份到本地的字符数组变量中

- 如果需要修改字符串，应该用数组：

  ```c
  char s[] = "Hello,world";
  char s[] ={'H','e','l','l','0',',','w','o','r','l','d','\0'};
  ```

#### 指针还是数组？

- ```c
  char *str = "Hello";
  char word[] = "Hello";
  ```

- 数组：这个字符串在这里，需要修改字符串内容的情况下用数组

  - 作为本地变量空间自动被回收

- 指针：这个字符串不知道在哪里，也就是只读情况下用指针

  - 处理参数
  - 动态分配空间

- 如果要构造一个字符串-->数组，可以修改字符串值

- 如果要处理一个字符串-->指针，也就是不修改字符串值

#### char*是字符串？错！

- 字符串可以表达为char*的形式
- char*不一定是字符串
  - 本意是指向字符的指针，可能指向的是字符的数组（就像int*一样）
  - 只有它所指的字符数组有结尾的0，才能说它所指的是字符串

#### 字符串赋值

- ```c
  char *t="title"
  char *s
  s=t
  ```

- 并没有产生新的字符串，只是让指针s指向了t所指的字符串，对s的任何操作就是对t做的，也就是把字符串的首地址赋给了s

#### 字符串输入输出

- ```c
  char string[8]
  scanf("%s",string);
  printf("%s",string);
  ```

- scanf读入一个单词（到空格、tab或回车为止）

  - ![image-20250125111401565](image/image-20250125111401565.png)
  - ![image-20250125111503319](image/image-20250125111503319.png)

- scanf是不安全的，因为不知道要读入的内容的长度

#### 安全的输入

- ```c
  char string[8];
  scanf("%7s",string);
  ```

- 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小1

  - 下一次scanf从哪里开始？
  - 若第一个scanf读满要求的字符数量，则从对应的字符断开，剩下的给后续的scanf。
  - 若第一个scanf没读满就遇到空格、tab之类的，空格后面的给剩下的scanf

#### 常见错误

- ```c
  char *string;
  scanf("%s",string)；
  ```

- 以为char*是字符串类型，定义了一个字符串类型的变量就可以直接使用了

  - 由于没有对string初始化为0，所以不一定每次运行都出错

- 实际上之前说的string = “hello”不能修改的意思是“hello”中的内容不能修改，并不是string这个变量的内容不能修改。string可以等于其他字符串，因为只是个变量，所以要初始化

#### 空字符串

- ```c
  char buffer[100]="";
  ```

  - 这是一个空的字符串，buffer[0]='/0'

- ```c
  char buffer[]=""
  ```

  - 这个数组的长度只有1，且buffer[0]的内容是'/0'

#### 小任务

用字符数组的方式来写

- ![image-20250126115749831](image/image-20250126115749831.png)

#### 程序参数

- ```c
  int main(int argc,char const *argv[])
  ```

- argv[0]是命令本身

  - 当使用Unix的符号链接时，反映符号链接的名字
  - 实际上是Linux的内容，在赵虚左ROS那里有提过，后面再看看

#### 字符串函数

##### putchar

- ```c
  int putchar(int c);
  ```

- 向标准输出（也就是vs输出的那块黑屏）写一个字符

- 返回写了几个字符，EOF（-1）表示写失败（putchar函数为整形函数的原因）

##### getchar

- ```c
  int	getchar(void)
  ```

- 从标准输入读入一个字符

- 返回类型是int是为了返回EOF（-1）

  - Windows->Ctrl-Z
  - Unix->Ctrl-D
  - 也就是各个操作系统按下上述指令后将退出输入界面

#### shell

- 在电脑键盘和屏幕与你的程序之间还存在一个shell程序，shell负责把你的程序运行起来。
- 你输入给程序的东西经过shell处理再给程序，程序输出的东西经过shell处理再给电脑屏幕。
- shell具有行编辑的作用，你输入的东西在按回车之前都没有被送到程序那里。按下回车之后，shell会把输入内容送入一个很大的缓冲区，getchar程序会在缓冲区一个个读取字符，scanf程序会全部读取，但怎么读取决于scanf设置读什么类型的数据。
- 同时在程序输入输出完成后，缓冲区会有一个标志位，意为继续让程序等待输入，只有在按下Ctrl-Z(Windows)后，shell直接把程序关闭。
- ![image-20250126124712835](image/image-20250126124712835.png)

#### string.h中比较常用的字符串函数

- strlen

  - size_t strlen(const char *s);
  - 返回s的字符串长度（不包括结尾的0）

- strcmp

  - ```c
    int strcmp(const char*s1,const char*s2);
    ```

  - 比较两个字符串，返回：

    - 0：s1==s2
    - 1：s1>s2，只要比较结果大于0，s1<s2
    - -1:s1>s2，只要比较结果小于0，s1>s2

  - 数组与数组之间比较永远是比较它们之间的地址

  - ![image-20250126145718892](image/image-20250126145718892.png)

  - 空格在Ascll码中为32

  - ![image-20250126150015370](image/image-20250126150015370.png)

- strcpy

  - ```c
    char* strcpy(char *restrict dst,const char *restrict src);//注意第一个参数是目的操作数，第二个参数是源操作数
    ```

  - 把src的字符串copy到dst

    - restrict表明src和dst不重叠（C99）

  - 返回dst

    - 为了能链起代码来

  - 复制一个i字符串

  - ```c
    char *dst=(char*)malloc(stclen(src)+1);//这里加一是因为只分配了字符串中字符的长度对应的内存，后面结尾的'\0'没有分配
    strcpy(dst,src);
    ```

  - ![image-20250126152204174](image/image-20250126152204174.png)

- strcat

  - ```c
    char *strcat(char *restrict s1,const char *restrict s2);
    ```

  - 把s2copy到s1的后面，接成一个长的字符串

  - 返回s1

  - s1必须具有足够的空间，也就是数组具有足够的空间

- strchr

  - ```c
    char *strchr(const char *s,int c);
    ```

  - 从左开始找，字符串中第一个c所在的地址

- strrchr

  - ```c
    char *strrchr(const char *s,int c);
    ```

  - 从右开始找，字符串中第一个c所在的地址

  - 返回NULL表示没有找到

- 字符串中找字符串

  - ```c
    char *strstr(const char *s1,const char *s2);
    char *strcasestr(const char*s1,const char *s2);
    ```

### 枚举

#### 常量符号化

- 用符号而不是具体的数字来表示程序中的数字
- ![image-20240927175257224](C语言.assets/image-20240927175257224.png)

枚举定义符号表示有顺序的数字

- 用枚举而不是定义独立的const
- ![image-20240927181137097](C语言.assets/image-20240927181137097.png)

- 枚举是一种用户定义的数据类型，它用关键字enum以如下语法来声明：

  ```c
  enum 枚举类型名字{名字0，名字1,...,名字n}；
  ```

- 枚举类型名字通常并不真的使用，要用的是在大括号力的名字，因为他们就是常量符号，他们的类型是int,值则以此从0到n。如：

  ```c
  enum colors{red,yellow,green};
  ```

- 就创建了三个常量，red的值是0，yellow的是1，而green是2。

- 当需要一些可以排列起来的常量值时，定义枚举的意义就是给了这下常量值名字。

- ![image-20240928123942477](image/image-20240928123942477.png)

- 枚举量可以作为值

- 枚举类型可以跟上enum作为类型

- 但是实际上是以整数来做内部计算和外部输入输出的

#### 套路：自动计数的枚举

![image-20240928124122820](image/image-20240928124122820.png)

- 这样需要遍历所有的枚举量或者需要建立一个用枚举量做下标的数组的时候就很方便了

#### 枚举量

- 声明枚举量的时候可以指定值
  - enum COLOR{RED=1,YELLOW,GREEN=5};
- ![image-20240928124333158](image/image-20240928124333158.png)

#### 枚举只是int

- 即使给枚举类型的变量赋不存在的整数值也没有任何warning或error
- ![image-20240928125017937](image/image-20240928125017937.png)

#### 注意事项

- 虽然枚举类型可以当作类型使用，但是实际上不好用
- 如果有意义上排比的名字，用枚举比const int方便
- 枚举比宏（macro），因为枚举有int类型

### 结构体

#### 声明结构体类型

![image-20240928132645211](image/image-20240928132645211.png)

#### 在函数内外声明？

- 和本地变量一样，在函数内部声明的结构类型只能在函数内部使用
- 所以通常在函数外部声明结构类型，这样就可以被多个函数所使用了

![image-20240928153647816](image/image-20240928153647816.png)

#### 声明结构的形式

- ```c
  struct point 
  {
   int x;
   int y;
  };
  struct point p1,p2;
  //p1和p2里面都有x和y的值
  ```

- ```c
  struct
  {
   int x;
   int y;
  }p1,p2;
  //p1和p2都是一种无名结构，里面有x和y
  ```

- ```c
  struct point
  {
   int x;
   int y;
  }p1.p2;
  //p1和p2都是point里面有x和y的值t
  ```

- 对于第一和第三章形式，都声明了结构point。但是第二种形式没有声明point，只是定义了两个变量。

#### 结构体的初始化

![image-20240928154409779](image/image-20240928154409779.png)

#### 结构体成员

- 结构和数组有点像
- 数组用[]运算符和下标访问其成员
  - a[0]=10
- 结构用.运算符和名字访问其成员
  - tody.day
  - student.firstName
  - p1.x
  - p1.y

#### 结构体运算

- 要访问整个结构，直接用结构变量的名字
- 对于整个结构，可以做赋值、取地址，也可以传递给函数参数
  - p1=(struct point){5,10};//相当于p1.x=5,p1.y=10;
  - p1 = p2;//相当于p1.x = p2.x;p1.y = p2.y;

#### 结构体指针

- 和数组不同，结构变量的名字并不是结构变量的地址，必须使用&运算符

- ```c
  struct date *pDate = &today;
  ```


- 如果一个大的结构体被传入函数，最有效的方式是传入一个指针而不是复制整个结构体进去

#### 结构体作为参数函数

```c
int numberofDays(struct date d)
```

- 整个结构可以作为参数的值传入函数
- 这时候是在函数内新建一个结构变量，并复制调用者的结构的值
- 也可以返回一个结构
- 这与数组完全不同

#### 值输入结构体

- 没有直接的方式可以一次scanf一个结构
- 如果我们打算写一个函数来读入结构
- 但是读入的结构如何送回来呢？
- 记住C在函数调用时是传值的
  - 所以函数中的p与main中的y是不同的
  - 在函数读入了p的数值之后，没有任何东西回到main，所以y还是{0,0}
- ![image-20240929103051178](image/image-20240929103051178.png)

#### 解决的方案

- 之前的方案，把一个结构传入了函数，然后在函数中操作，但是没有返回回去
  - 问题在于传入函数的是外面那个结构的克隆体，而不是指针
    - 传入结构和传入数组是不同的
- 在这个输入函数中，完全可以创建一个临时的结构变量，然后把这个结构返回给调用者

- ![image-20240929105501543](image/image-20240929105501543.png)

#### 指向结构体的指针

- 用->表示指针所指的结构变量中的成员
- ![image-20240929105956387](image/image-20240929105956387.png)

#### 结构体指针参数

![image-20240929110052868](image/image-20240929110052868.png)

![image-20250208202441402](image/image-20250208202441402.png)

虽然重点是结构体指针作为参数，但是结构体指针类型的函数居然不用把返回值赋给某个指针变量是我没想到的。

#### 结构体数组

结构体数组是一个由结构体类型的元素组成的数组。这种数组允许我们多个存储多个结构体，并可以通过索引来访问每个结构体。

##### 定义结构体

首先需要定义一个结构体类型，比如定义一个代表学生信息的结构体：

```c
#include <stdio.h>

struct Student {
    char name[50];
    int age;
    float gpa;
};
```

##### 定义结构体数组

例如定义一个包含100个学生的数组：

```c
struct Student students[100];
```

##### 初始化结构体数组

可以在定义时初始化数组：

```c
struct Student students[3] = {
    {"Alice", 20, 3.5},
    {"Bob", 21, 3.7},
    {"Charlie", 19, 3.8}
};
```

或者在程序运行时逐个初始化：

```c
strcpy(students[0].name, "Alice");
students[0].age = 20;
students[0].gpa = 3.5;

strcpy(students[1].name, "Bob");
students[1].age = 21;
students[1].gpa = 3.7;

strcpy(students[2].name, "Charlie");
students[2].age = 19;
students[2].gpa = 3.8;
```

注意：strcpy函数用于将字符串复制到结构体成员中

##### 访问和修改结构体数组的元素

可以通过数组索引来访问和修改结构体数组的元素：

```c
printf("Name: %s, Age: %d, GPA: %.2f\n", students[0].name, students[0].age, students[0].gpa);

students[1].age = 22; // 修改Bob的年龄
printf("Name: %s, Age: %d, GPA: %.2f\n", students[1].name, students[1].age, students[1].gpa);
```

##### 遍历结构体数组

使用循环来遍历结构体数组：

```c
for (int i = 0; i < 3; i++) {
    printf("Name: %s, Age: %d, GPA: %.2f\n", students[i].name, students[i].age, students[i].gpa);
}
```

示例

```c
#include <stdio.h>
#include <string.h>

struct Student {
    char name[50];
    int age;
    float gpa;
};

int main() {
    struct Student students[3];

    // 初始化
    strcpy(students[0].name, "Alice");
    students[0].age = 20;
    students[0].gpa = 3.5;

    strcpy(students[1].name, "Bob");
    students[1].age = 21;
    students[1].gpa = 3.7;

    strcpy(students[2].name, "Charlie");
    students[2].age = 19;
    students[2].gpa = 3.8;

    // 输出
    for (int i = 0; i < 3; i++) {
        printf("Name: %s, Age: %d, GPA: %.2f\n", students[i].name, students[i].age, students[i].gpa);
    }

    return 0;
}
```

##### 高级用法

动态分配结构体数组，使用malloc动态分配

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Student {
    char name[50];
    int age;
    float gpa;
};

int main() {
    int n;
    printf("Enter the number of students: ");
    scanf("%d", &n);

    // 动态分配内存
    struct Student *students = (struct Student*)malloc(n * sizeof(struct Student));
    if (students == NULL) {
        printf("Memory allocation failed\n");
        return 1;
    }

    // 初始化
    for (int i = 0; i < n; i++) {
        printf("Enter name, age, and GPA for student %d:\n", i + 1);
        scanf("%s %d %f", students[i].name, &students[i].age, &students[i].gpa);
    }

    // 输出
    for (int i = 0; i < n; i++) {
        printf("Name: %s, Age: %d, GPA: %.2f\n", students[i].name, students[i].age, students[i].gpa);
    }

    // 释放内存
    free(students);

    return 0;
}
```

##### 结构体数组作为函数参数

```c
void printStudents(struct Student *students, int n) {
    for (int i = 0; i < n; i++) {
        printf("Name: %s, Age: %d, GPA: %.2f\n", students[i].name, students[i].age, students[i].gpa);
    }
}

int main() {
    struct Student students[3] = {
        {"Alice", 20, 3.5},
        {"Bob", 21, 3.7},
        {"Charlie", 19, 3.8}
    };

    printStudents(students, 3);

    return 0;
}
```

### 自定义数据类型（typedef）

- C语言提供了一个叫做typedef的功能来声明一个已有的数据类型的新名字。比如：typedef int Length

- 使得Length成为int类型的别名

- 这样，Length这个名字就可以替代int出现在变量定义和参数声明的地方了：

- ```c
  Length a,b,len;
  Length numbers[10];
  ```

#### 声明新的类型的名字

- 新的名字是某种类型的别名
- 改善了程序的可读性
- ![image-20240929204329075](image/image-20240929204329075.png)

- 此处struct ADate结构体的结构在定义的同时，被重新加载了新的类型名字Date，也就是Date直接代替了struct ADate

- ![image-20250208202658546](image/image-20250208202658546.png)

- 后边就能以Date作为新的结构体类型名称声明结构体变量

- 示例：

- ```c
  typedef struct
  {
  int month;
  int day;
  int year;
  }Date;//struct不用定义变量名都行，后边都会被Date代替
  ```

#### 总结

- ```c
  typedef int Length;//Length就等价于int类型
  ```

- ```c
  typedef *char[10]Strings;//Strings是10个字符指针(字符串？)的数组的类型
  typedef struct node
  {
      int data;
      struct node *next;
  }aNode;
  
  or
  
   typedef struct node aNode;//这样用aNode就可以代替struct node
  ```

### 全局变量

![image-20241007115149554](image/image-20241007115149554.png)

![image-20241007115612471](image/image-20241007115612471.png)

- 定义在函数外面的变量是全局变量
- 全局变量具有全局的生存期和作用域
  - 它们与任何函数都无关
  - 在任何函数内部都可以使用他们
- 额外知识：____func___在函数里边表示当前函数的名字   
- ![image-20240929222152214](image/image-20240929222152214.png)

#### 全局变量初始化

- 没有做初始化的全局变量会得到0值
  - 指针会得到NULL值
- 只能用编译时刻已知的值来初始化全局变量
- 它们的初始化发生在main函数之前

#### 被隐藏的全局变量

- 如果函数内部存在与全局变量同名的变量，则全局变量被隐藏

![image-20241007130432640](image/image-20241007130432640.png)

#### 静态本地变量

- 在本地变量定义时加上static修饰符就成为静态本地变量
- 当函数离开的时候，静态本地变量会继续存在并保持其值
- 静态本地变量的初始化只会在第一次进入这个函数时做，以后进入函数时会保持上次离开时的值

![image-20241007130646590](image/image-20241007130646590.png)

##### 实质

- 静态本地变量实际上时特殊的全局变量
- 它们位于相同的内存区域
- 静态本地变量具有全局的生存期，函数内的局部作用域。也就是跟全局变量一样，值会保持着它上次被操作的值大小，但是它作用的地方只能在函数里边。
  - static在这里的意思是局部作用域（本地可访问）

![image-20241007130916849](image/image-20241007130916849.png)

#### *返回指针的函数

- 返回本地变量的地址是危险的
- 返回全局变量或静态本地变量的地址是安全的
- 返回在函数内malloc的内存是安全的，但是容易造成问题
- 最好的做法是返回传入的指针

#### tips

- 不要使用全局变量来在函数间传递函数和结果
- 尽量避免使用全局变量
- *使用全局变量和静态本地变量的函数是线程不安全的

### 编译预处理和宏

#### 编译预处理指令

- #开头的是编译预处理指令
- 它们不是C语言的成分，但是C语言程序离不开它们
- #define用来定义一个宏
- ![image-20241007163253420](image/image-20241007163253420.png)
- 每次编译前，编译器会做一次编译预处理，把所有宏都替换为其被定义的值
- 整个编译过程，源文件被编译成可执行文件的过程
- ![image-20241007163553330](image/image-20241007163553330.png)
- .c为我们编写的源文件，经过编译预处理把宏替换为所定义的值得到.i文件。.i开始才为编译，编译得到汇编文件.s。.s经过汇编得到目标代码文件.o，.o经过链接得到可执行文件。

#### #define

- #define<名字><值>
- 注意没有结尾的分号，以为不是C的语句
- 名字必须是一个单词，只可以是各种东西
- 在C语言的编译器开始编译之前，编译预处理程序(cpp)会把程序中的名字替换成值
  - 完全的文本替换
- gcc--save-temps

#### 宏

- 如果一个宏的值中有其他宏的名字，也是会被替换的
- 如果一个宏的值超过一行，最后一行之前的行末需要加\
- ![image-20241007164650050](image/image-20241007164650050.png)
- 宏的值后面出现的注释不会被当作宏的值的一部分
- ![image-20241007164545547](image/image-20241007164545547.png)

#### 没有值的宏

- #define _DEBUG
- 这类宏是用于条件编译的，后面有其他的编译预处理指令来检查这个宏是否已经被定义过了

#### 预定义的宏

- —LINE—源代码文件的当前所在位置的行号
- —FILE—源代码文件的文件名
- —DATE—源代码编译时的日期
- —TIEM—源代码编译时的时间
- —STDC—
- ![image-20241007165126364](image/image-20241007165126364.png)

#### 像函数的宏

- ```c
  #define cube(x) ((x)*(x)*(x)) 
  ```

- 宏可以带参数

- ![image-20241007171125682](image/image-20241007171125682.png)

#### 带参数的宏的原则

- 一切都要括号
  - 整个值要括号
  - 参数出现的每个地方都要括号
- #define RADTODEG(x) ((x)*57.29578)
- 可以带多个参数
  - #define MIN(a,b) ((a)>(b)?(b):(a))
- 也可以组合（嵌套）使用其他宏
- 在大型程序的代码中使用非常普遍

### 大程序结构

#### 需求：多个.c文件

- main()里的代码太长了，适合分成几个函数
- 一个源代码文件太长了，适合分成几个文件
- 两个独立的源代码文件不能编译形成可执行的程序

#### 项目

- 在IDE中新建一个项目，然后把几个源代码文件加入进去
- 对于项目，IDE的编译会把一个项目的所有源代码文件都编译后，链接起来
- 有的IDE有分开的编译和构建两个按钮，前者时对单个源代码文件编译，后者是对整个项目做链接

#### 编译单元

- 一个.c文件是一个编译单元
- 编译器每次编译只处理一个编译单元

#### 头文件

- 把函数原型放到一个头文件（以.h结尾）中，在需要调用这个函数的源代码文件（.c文件）中#include这个头文件，就能让编译器在编译的时候知道函数的原型
- ![image-20241007205614508](image/image-20241007205614508.png)
- ![image-20241007205646299](image/image-20241007205646299.png)

#### #include

- #include是一个编译预处理指令，和宏一样，在编译之前就处理了
- 他把那个文件的全部文本内容原封不动地插入到它所在的地方
  - 所以也不是一定要在.c文件的最前面#include

#### ""还是<>

- #include有两种形式来指出要插入的文件
  - ""要求编译器首先在当前目录（.c文件所在的目录）寻找这个文件，如果没有，到编译器指定的目录去找
  - <>让编译器只在指定的目录去找
- 编译器自己知道自己的标准库的头文件在哪里
- 环境变量和编译器命令行参数也可以指定寻找头文件的目录

#### #include的误区

- #include不是用来引入库的
- stdio.h里只要printf的原型，printf的代码在另外的地方，某个.lib(Window)或.a(Unix)中
- 现在的C语言编译器默认会引入所有的标准库
- #include<stdio.h>只是为了让编译器知道printf函数的原型，保证你调用时给出的参数值是正确的类型

#### 变量的声明

- int i;是变量的定义
- extern int i;是变量的声明
- ![image-20241007221008386](image/image-20241007221008386.png)

#### 声明和定义

- 声明是不产生代码的东西（编译器看到你的声明并不会为其产生代码，而是记下来，知道项目的某个地方有你声明的东西）
  - 函数原型
  - 变量声明
  - 结构声明
  - 宏声明
  - 枚举声明
  - 类型声明
  - inline函数
- 定义是产生代码的东西（函数、全局变量）

#### 头文件

- 只有声明可以被放在头文件中
  - 是规律不是法律
- 否则会造成一个项目中多个编译单元里有重名的实体

#### 重复声明

- 同一个编译单元里，同名的结构不能被重复声明
- 如果你的头文件里有结构的声明，很难这个头文件不会在一个编译单元里被#include多次
- 所以需要"标准头文件结构"

#### 标准头文件结构

![image-20241007221908905](image/image-20241007221908905.png)

- 运用条件编译和宏，保证这个头文件在一个编译单元中之后被#include一次
- #ifndef的意思是如果你没有定义 ____LIST_HEAD____这个宏的话，进入到下一语句#define ____LIST_HEAD____，定义这个宏，定义的内容到#endif为止
- #pragma once也能起到相同的作用，但是不是所有的编译器都支持

### 测试代码

直接用大括号{}，内部写函数内容，不写函数名和参数

![image-20240922221010686](C语言.assets/image-20240922221010686.png)



平方根函数：sqrt(x)，需要包含<math.h>