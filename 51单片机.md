# 51单片机

![image-20241008185350277](image/image-20241008185350277.png)

## LED

### 硬件原理

- ![image-20241008003304713](image/image-20241008003304713.png)

- ![image-20241008003356265](image/image-20241008003356265.png)
- LED在上电时，负极默认接高电平，只有当使用者改变LED负极引脚对于的io口输出电平才能使其亮

## 电阻

102 = 1K（后边的2其实是10的2次方）

10 00 = 1K

同理，473

47*10^3

47 000 = 47K

### TTL电平

单片机使用的一种电平规范，规定了高电平是5V，低电平是0V

### RS232电平

单片机使用的一种电平规范，规定了高电平是15V，低电平是-15V

#### 引脚地址

![image-20241008093235549](image/image-20241008093235549.png)

这里的P2首地址应该是指P2.0的地址

然后直接操作寄存器8位点灯

![image-20241008093901766](image/image-20241008093901766.png)

置零才能点亮灯，因为led的负极接的是引脚。其实不加下边那个循环好像灯也不会灭

### 延时函数

```c
void Delay500ms()		//@12.000MHz
{
	unsigned char i, j, k;

	_nop_();
	i = 4;
	j = 205;
	k = 187;
	do
	{
		do
		{
			while (--k);
		} while (--j);
	} while (--i);
}
```

- 时钟周期=1/晶振频率
- 机器周期：完成一个基本操作所需要的时间
- 基本操作：取指令，存储器读，存储器写
- nop是汇编指令集里的空操作，运行一个机器周期，一个机器周期等于十二个晶振周期（这是人工规定的准则吗？），可用于验证延时功能

## 数据类型

int 16位（单片机） 32位（PC）

![image-20241008232220399](image/image-20241008232220399.png)

还有bool类型，True（1）和False（0）

## 数据运算

![image-20241009145941893](image/image-20241009145941893.png)

## 按键开关

- 相当于是一种电子开关，按下时开关接通，松开时开关断开，实现原理是通过轻触按键内部的金属弹片受力弹动来实现接通和断开

- ![image-20241009151241977](image/image-20241009151241977.png)

#### 原理图

- ![image-20241009151410301](image/image-20241009151410301.png)
- 引脚是读取实时电平值的，当开关按下时，引脚与GND接通，读到低电平
- 当开关松开，读到高电平

#### 按键的抖动

- ![image-20241009155457970](image/image-20241009155457970.png)
- 对于机械开关，当机械触点断开、闭合时，由于机械触点的弹性作用，一个开关在闭合时不会马上稳定地接通，在断开时也不会一下子断开，所以在开关闭合及断开的瞬间会伴随一连串的抖动
- 此时需要消抖来减少对程序的影响，一般常用软件消抖，即延时一定时间。通常在完成开关断开的消抖后才继续执行剩下的程序,即当你松开开关的那一刻程序开始往下执行

#### 寄存器操作

- 由于八个LED灯可由八位寄存器直接操作亮灭，因此可以定义一个无符号八位的变量，从而直接将变量内存储的值赋给寄存器，达到操作寄存器的结果。
  - 此次无符号八位变量可以通过定义无符号char类型变量实现，无需担心字符型变量会怎么样，它现在只作为一个八位存储器使用
  - 变量名称只能用字母、数字、下划线组成
- 在编译器中，输入十进制、十六进制的的数据在编译完以后都会变成二进制的数据，因此无论是将相同值的二进制、十进制、十六进制数据直接赋给寄存器，都能达到相同的结果。
  - 注意：C51的编译规则无法直接将二进制数据赋给寄存器，C99可以

### LED数码管

- LED数码管是一种简单、廉价的显示器，是由多个发光二级管封装在一起组成8字型的器件
- ![image-20241011104044792](image/image-20241011104044792.png)

#### 数码管引脚定义

- ![image-20241011104149635](image/image-20241011104149635.png)
- 共阴极连接（51上所采用的连接方式）
  - ![image-20241011104224976](image/image-20241011104224976.png)
- 共阳极连接
  - ![image-20241011104251285](image/image-20241011104251285.png)

#### 多数码管引脚定义

- ![image-20241011104512825](image/image-20241011104512825.png)
- ![image-20241011104721829](image/image-20241011104721829.png)
- 上边的12、9、8、6号引脚是分别控制不同位置的数码管亮灭的总开关
- 同时可得出的结论是，一个多数码管无法同时表现出不同的数字，即使有多个数码管同时亮，上面所显示的数字都是一样的。

#### 多数码管显示

- 多数码管显示要注意**消影**的问题，即单数码管的的显示一般的过程是：选位、段选，如果是多数码管的过程：选位-段选-选位-段选-选位-段选，第一段程序的段选和第二段程序的选位会杂糅在一起，从而第二、三、四个数码管的显示会有前一数字的重影
- ![image-20241012172006978](image/image-20241012172006978.png)重影
- ![image-20241012172109930](image/image-20241012172109930.png)消影
- 消影的步骤：段选后延迟1ms，然后将数码管段选置零

#### 数码管驱动方式

- 单片机直接扫描：硬件设备简单，但会耗费大量单片机CPU时间
- 专用驱动芯片：内部自带显存、扫描电路，单片机只需告诉他显示什么即可

### 双向数据缓冲器

- ![image-20241011112807063](image/image-20241011112807063.png)

- DIR如果接高电平，数据从左边传输到右边；如果接低电平，就把右边数据读回到左边
- 通过LE位接高低电平，LE位其实是跳线帽，可以直接将LE与另一位短接
- OE为芯片使能位，接地使能，接VCC则失能
- 接数据缓冲器的原因是，MCU的信号直接接到数码管上，灯的亮度会很暗，因为MCU输出的电流小。因此将MCU的输出当作控制信号，再由数据缓冲器增大电流后输出，可以使得数码管亮度更亮
- RP4为限流电阻，防止输送的电流过大

### 数据传输

- 十六进制数据如果有已经固定一一对应的值，如下图，则可以定义无符号字符型数组存储对应的十六进制数据，以后像是直接操作寄存器值的行为可以参考使用数组存储对应的值
- ![image-20241012002321788](image/image-20241012002321788.png)
- 然后有些情况下只能操作三位二进制的引脚，这时候可以使用switch语句来赋予对应引脚值，case值可宏定义以便读者观看对应的引脚
- ![image-20241012002756281](image/image-20241012002756281.png)
- ![image-20241012002814241](image/image-20241012002814241.png)

### 模块化编程

- 传统方式编程：所有的函数均放在main.c里，若使用的模块比较多，则一个文件内会有很多的代码，不利于代码的组织和管理，而且很影响编程者的思路
- 模块化编程：把各个模块的代码放在不同的.c文件里，在.h文件里提供外部可调用函数的声明，其他.c文件想使用其中的代码时，只需要#include"XXX.H"包含头文件即可。使用模块化编程可极大的提高代码的可阅读性、可维护性、可移植性等
- 具体实例：
- ![image-20241013111914802](image/image-20241013111914802.png)

#### 模块化编程注意事项

- .c文件：函数、变量的定义
- .h文件：可被外部调用的函数、变量的声明
- 任何自定义的变量、函数在调用前必须有定义或声明（同一个.c），例如在main函数里使用Delay()函数必须先包含"Delay.h"
- 使用到的自定义函数的.c文件必须添加到工程参与编译，也就是必须把c文件放到Project里，![image-20241013115538343](image/image-20241013115538343.png)
- 使用的.h文件必须要放在编译器可寻找到的地方（工程文件夹根目录、安装目录、自定义）

#### C预编译

- C语言的预编译以#开头，作用是在真正的编译开始之前，对代码做一些处理（预编译）
- ![image-20241013112910974](image/image-20241013112910974.png)
- 此外还有#ifdef（如果定义了）,#if,#else,#elif,#undef等

#### 头文件包含范围的区别

![image-20241013101924684](image/image-20241013101924684.png)

- <>与""的区别是<>在软件安装目录里寻找头文件，""在当前程序文件目录里寻找文件



### STC89C52单片机的I/O口结构

#### I/O口配置

- 有三种工作类型：准双向口/弱上拉(标准8051输出模式)、仅为输入(高阻)或开漏输出功能。
- 弱上拉模式，io口输出的1的驱动能力比较弱，输出的0的驱动能力比较强（准双向口输出类型可用作输出和输入功能而不需重新配置口线输出状态。这是因为当口线输出为1时驱动能力很弱，允许外部装置将其拉低。当引脚输出为低时，它的驱动能力很强，可吸收相当大的电流。）

### 程序下载

[一文彻底搞懂单片机程序烧录](https://blog.csdn.net/ZHOU_YONG915/article/details/122842967)

[STM32启动配置和自动串口下载](https://blog.csdn.net/ZHOU_YONG915/article/details/136841873)

[51单片机烧录那点事儿](https://blog.csdn.net/ZHOU_YONG915/article/details/125822094?ops_request_misc=&request_id=&biz_id=102&utm_term=51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%83%A7%E5%BD%95%E5%8E%9F%E7%90%86&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-125822094.142^v101^pc_search_result_base5&spm=1018.2226.3001.4187)

#### 编程器编程

单片机程序下载的本质就是将由0和1组成的二进制文件（hex格式或bin格式）写入到掉电数据不会消失的EEPROM（Electrically Erasable Programmable Read Only Memory，电可擦除可编程只读存储器）中。

#### ISP（In System Programming, 系统在线编程）

**ISP基本是目前单片机烧录程序的主要方式**。它的实现方式就是通过电脑端的上位机软件，通过某种数据传输协议（**串口、SPI、SWD、JTAG**），将**程序编译产生的二进制文件**烧录到单片机的EEPROM中。如STC的51单片机基于串口协议，即程序通过串口写入到FLASH（EEPROM中的一种）；Atmel的AT89S52系列单片机基于SPI协议；STM32系列芯片采用**ST-Link、J-Link**等设备来下载程序，其基于的协议是**SWD和JATG**，当然STM32**也可以基于串口协议**下载程序（那个fly什么的上位机）。

虽然以上各种协议都算ISP，但是最特殊的一种莫过于串口协议，因为其他各种协议都是借助外部设备（如ST-Link、USBasp）来**直接操作单片机的FLASH**，而通过串口下载程序时，虽然也需要借助外部设备（一般是一个USB转TTL模块），**但是其本质还是靠芯片内部已固化的一段程序来更新FLASH**。

用来写入FLASH的这部分程序是芯片出厂就已经固化到芯片当中的，称为**引导程序**，英文名叫**BootLoader**。

因此，为实现这种功能，芯片内部ROM可以分为两部分，一部分是**系统存储区**（System Flash），一般在高地址，用来**存放引导程序**；另一部分是**用户存储区**（User Flash），一般在低地址，用来**存放用户编写的程序**（主要运行的部分）。

以STM32为例，由于它既支持SWD，JTAG这种直接操作FLASH的协议，也支持基于串口协议利用引导程序写入FLASH，因此它需要支持多种启动模式。如下图所示。

![img](https://i-blog.csdnimg.cn/blog_migrate/8aa6835198b6861cc419f25ef6b37c17.png#pic_center)

这里的“主闪存存储器”即上面提到的用户存储区，用来存放用户编写的程序。

如果手边有ST-Link或者J-Link就可以考虑从用户存储区开始运行，这样上位机就直接将数据写入到用户存储区的FLASH中；如果要采用串口下载，就需要从系统存储区开始启动，当芯片在这个部分开始执行程序时，会不断检测串口是否有写入FLASH的指令，如果有，则开始写入用户存储区的FLASH，**如果没有，也无法跳转到用户存储区运行，只能调整BOOT模式再复位。**

但是一般串口下载要更慢，而且ST-Link和J-Link出来下载程序外，还支持硬件仿真（是指Debug吗？），这也就是为什么用串口下载的比较少

和STM32串口下载比较类似的还有STC单片机，官方数据手册对于程序下载的流程介绍如下图所示：

![img](https://i-blog.csdnimg.cn/blog_migrate/3eb74eb97c1b8eca76736f3714ffd71f.png#pic_center)

可以看出，**和STM32最大的差别在于STC51单片机不存在一个系统存储区的死循环，内置的bootloader和用户程序是先后执行的关系。这样好处很明显，那就是不用选择启动模式；坏处也很明显，那就是每次上电都必须运行这个bootloader，对于上电之后启动速度有较高要求的场景来说就可能会有点问题。**

**FLASH存储器可以看作是EEPROM的一种**。

### 定时器

#### 定时器介绍

- 51单片机的定时器属于单片机的内部资源，其电路的连接和运转均在单片机内部完成
- 定时器作用：
  - 用于计时系统，可实现软件计时，或者是程序每隔一段固定时间完成一项操作
  - 替代长时间的delay()，提高CPU运行效率和处理速度

#### STC89C52定时器资源

- 定时器个数：3个（T0、T1、T2），T0与T1是传统51单片机固有的定时器资源，T2是此型号单片机增加的资源

#### 定时器框图

- 定时器在单片机内部就像一个闹钟，每隔一定的时间间隔计数值就会加一（该时间间隔叫做系统时钟，由单片机的晶振提供，也就是晶振周期）。当计数单元到达一定的计数值时（到点）产生溢出，就会向中断系统发出中断请求（响铃提醒），使程序跳转到中断服务函数中执行
- ![image-20241026171439411](image/image-20241026171439411.png)

#### 定时器工作模式

- STC89C52的T0和T1均有四种工作模式：
  - 模式0：13位定时器/计数器
  - 模式1：16位定时器/计数器（常用）
  - 模式2：8位自动重装模式
  - 模式3：两个8位计数器
- 工作模式1框图：
- ![image-20241026173216059](image/image-20241026173216059.png)
- 晶振每振动一次产生一个脉冲，计数器就加一
- TR0控制定时器是否启动
- C/T位置0，为定时器；置1，为计数器
- GATE置0，由TR0单独控制定时器启动；GATE置1，由INT0外部中断位与TR0共同控制定时器启动

#### 定时器时钟

- SYSclk：系统时钟，即晶振周期，晶振振动一次所需的时间，51单片机开发板上的晶振频率为12Mhz。晶振振动会产生脉冲，一般将这个脉冲信号称为系统时钟信号。但一般会经过分频来使用系统时钟，比如，定时器模式下对系统频率进行12分频，则系统频率变成1Mhz。即原本1个系统时钟定时器计数一次，现在要12个系统时钟，定时器才计数一次即得到一次计数脉冲，计数周期也变成1微秒一次。也就是**机器周期为十二个系统时钟**的由来。
- ![image-20241026155233520](image/image-20241026155233520.png)

### 中断系统

#### 中断系统介绍

- 中断系统是为了使**CPU**具有对外界紧急事件的**实时处理能力而设置的**
- 当CPU正在处理某件事的时候外界发生了紧急事件请求，要求CPU暂停当前的工作，转而去处理这个紧急事件，处理完以后回到**原来被中断的地方继续原来的工作**，这个过程就称为中断。实现这种功能的部件称为中断系统，请示CPU中断的请求源称为中断源。中断系统一般允许多个中断源，当几个中断源同时发起中断请求时，需要按照中断优先级依次执行中断服务程序，CPU总是先响应**优先级别最高的中断请求**。
- 当CPU在处理一个中断源请求的时候（**执行相应的中断服务程序**），发生了另一个优先级比它还高的中断源请求。如果CPU能暂停对原来中断源的服务程序，**转而去处理优先级比它还高的中断请求源**，处理完以后再回到原低级中断服务程序，这样的过程称为**中断嵌套**。这样的中断系统称为**多级中断系统**，没有中断嵌套功能的中断系统称为单极中断系统。

#### 中断程序流程

- ![image-20241026193133149](image/image-20241026193133149.png)

#### 中断资源

- 中断源个数：8个（外部中断0、定时器中断0、外部中断1、定时器中断1、串口中断、定时器中断2、外部中断2、外部中断3）
- 中断优先级个数：4个，其中数字越高优先级越高，即从高到低：3 2 1 0
- 中断号：![image-20250109110213788](image/image-20250109110213788.png)

定时器和中断系统的连接

![image-20241026194217729](image/image-20241026194217729.png)

#### 定时器相关寄存器

![image-20241026195828618](image/image-20241026195828618.png)

![image-20241026195914766](image/image-20241026195914766.png)

- 定时器相关且比较常用的寄存器有TCON、TMOD、TL0、TH0、TL1、TH1
- 中断相关且比较常用的寄存器有IE、IP（中断优先级）

#### 定时器配置

- TCON：TR0置1允许T0开始计数
- TMOD：C/T置0，定时器模式；M1置0，M0置1，选择16位定时器
- TH0、TL0为计数单元

#### 中断配置

- IE：EA置1，CPU开放所有中断源的申请；ET0\ET1\ET2，允许各个定时器中断
- IP与IPH：PT0与PTH0一起用，决定中断的优先级
- ![image-20241026205457173](image/image-20241026205457173.png)

#### 中断实时流程

- **当每次计数器计数溢出，中断发生后，计数器默认从0开始计数。因此如果想按照固定时间发生中断，要记得中断服务函数里面将计数器赋予对应的初值。**
- 中断里执行对不同变量的操作的前提是，变量不能在主函数的循环里变化，否则中断函数里对变量的操作可能会发生冲突。主函数的循环时间与定时器中断的循环时间不一样。
- ![image-20241027203404407](image/image-20241027203404407.png)
- ![image-20241027204551135](image/image-20241027204551135.png)

#### 额外知识

- 可位寻址代表可以单独给位赋值，不可位寻址则只能给寄存器整体赋值，即8位同时赋值。
- 大部分延时操作可以通过在定时器中断服务函数中定时调用各个模块的循环调用函数来代替，这样可以避免CPU进程阻塞。
- 并且要注意的是定时器中断服务函数中不能调用延时函数，否则会使上一时刻与这一时刻的中断服务函数执行发生重叠。

### 串口通信

#### 串口介绍

![image-20241031102108382](image/image-20241031102108382.png)

#### 硬件电路

- 简单双向串口通信有两根通信线（发送端TXD(transmit exchange data)和接收端RXD(receive exchange data)）
- TXD和RXD要交叉连接
- 当只需要单向的数据传输时，可以直接一根通信线
- 当电平标准不一致时，需要加电平转换芯片（比如降压模块升压模块）
- ![image-20241031102502286](image/image-20241031102502286.png)

#### 电平标准

- 电平标准是数据1和数据0的表达方式，是传输线缆中人为规定的电压与数据的对应关系，串口常用的电平标准有如下三种：
- TTL电平：+5V表示1，0V表示0
- RS232电平：-3~-15V表示1， +3~+15表示0
- RS485电平：两线（TXD与RXD）压差+2~+6V表示1，-2 ~-6V表示0（差分信号）
- TTL和RS232通讯协议信号传输只能13米以内，RS485是千米。RS232一般是用于电脑的电平标准，因为电压接受的范围大

#### 流控制

[UART串口流控制](https://blog.csdn.net/qq_42992084/article/details/104761474)

对于数据的接收与发送双方会有请求与响应

#### 常见通信接口比较

- ![image-20241031195441391](image/image-20241031195441391.png)
- 除此以外，还有：CAN（汽车领域的多传感器连接）、USB等

#### 相关术语

- 全双工：通信双方可以在同一时刻互相传输数据
- 半双工：通信双方可以互相传输数据，但必须分时复用一根数据线（也就是A发B收和B发A收同一时间只能执行一个）
- 单工：通信只能有一方发送到另一方，不能反向传输
- 异步：通信双方各自约定通信速率（也就是数据采样周期的规定，一秒发送一次信号，然后一秒采样一次和半秒采样一次的信号是不同的）异步就是约定输出和输入的速率，可以同时输入输出。**例如串口通信中双方可以设定不同的波特率来传输和接收数据，但是一般来说波特率要相同。**
- ![image-20241031201013549](image/image-20241031201013549.png)

- 同步：通信双方靠一根时钟线来约定通信速率。同步就类似于检测，有输出的数据了，另一头同步输入数据。检测上升沿来判断信号采样成功

- 总线：连接各个设备的数据传输线路（类似于一条马路，把路边各个用户连接起来，使用户可以相互交流，即相互传输信号）

上升沿：0->1

- 定时器溢出率：定时器溢出的频率，若定时器中断开启，则可以看作一秒钟发生多少个定时器中断
- 波特率：串口传输的波特率即为每秒钟传输二进制的位数，定时器有溢出就可以生成波特率？
  - [什么是波特率，波特率怎么计算](https://blog.csdn.net/qq_40147893/article/details/106539081?ops_request_misc=%257B%2522request%255Fid%2522%253A%25223A3B2366-DC30-473F-8D92-D6D27C9EBED1%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=3A3B2366-DC30-473F-8D92-D6D27C9EBED1&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-106539081-null-null.142^v100^pc_search_result_base9&utm_term=%E6%B3%A2%E7%89%B9%E7%8E%87&spm=1018.2226.3001.4187)
- 大端存储与小端存储
  - [计算机中的大端存储与小端存储](https://blog.csdn.net/weixin_43886592/article/details/106336154?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522e9fa6551e498f4f56c838c403da56658%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=e9fa6551e498f4f56c838c403da56658&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-6-106336154-null-null.142^v101^pc_search_result_base5&utm_term=%E5%A4%A7%E7%AB%AF%E5%AD%98%E5%82%A8%E5%92%8C%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8&spm=1018.2226.3001.4187)


#### 51单机的UART

![image-20241031201819262](image/image-20241031201819262.png)

#### 串口参数及时序图

- 波特率：串口通信的速率（一秒钟可以传输多少位二进制数，倒数为发送和接收各数据位的间隔时间）。发送与接收双方的波特率必须一致，否则数据传输会出错。
  
- 溢出率其实就是溢出频率，即溢出时间的倒数，一次溢出时间等于系统时钟* 12 * (256-定时器计数器高八位)，也就是一秒溢出多少次
  
- SMOD为51单片机中频率加倍标志
  - ![image-20241114204003190](image/image-20241114204003190.png)

- 检验位：用于数据验证（双方都约定好用什么校验方式）
  - 奇校验：即检测传输的信号中高电平1的位数必须是奇数位。如果信号里边是偶数位，检验位就会置1，从而得到奇数位高电平，如何检测位数由硬件解决。但是这种方式无法检测出乱序的情况，如下图所示：
  - ![image-20241031203457866](image/image-20241031203457866.png)
  - 偶校验：即检测传输的信号中高电平1的位数必须是偶数个。如果信号里边是奇数个，检验位就会置1，从而得到偶数个高电平
- 停止位：用于数据帧间隔
- ![image-20241031202714807](image/image-20241031202714807.png)
- 波特率表示电平变化的速度，比特率表示实际数据的传输速度

#### 串口模式图

![image-20241031212634979](image/image-20241031212634979.png)

- SBUF：串口数据缓存寄存器，物理上是两个独立的寄存器，但占用相同的地址。写操作时，写入的是发送寄存器（即要发送数据时，将数据写入发送寄存器再发送出去），读操作时，读出的是接收寄存器（即接收寄存器存储了对方发送的数据，若要读取数据，直接在接收寄存器中读取）。

#### 串口相关寄存器

![image-20241031220743162](image/image-20241031220743162.png)

#### 串口配置

- SCON：当PCON的SMOD0置0时，SM0和SM1一同决定串口的工作模式
  - ![image-20250116110217635](image/image-20250116110217635.png)
  - SM2：允许方式2或3多机通信控制位，暂时用不到，用到去数据手册看
  - REN：允许/禁止串行接受控制位。由软件置位REN，即REN=1时位允许串行接收状态，可以启动串行接收器RXD，开始接收信息。软件复位REN，即REN=0，则进制接收
  - TB8和TB9都是用于方式2和3
  - TI：发送中断请求标志位，在方式1中，在停止位开始发送时有内部硬件置1，即TI=1，向主机请求中断，响应中断后必须由软件复位。
  - RI：接收中断请求标志位，在方式1中，串行接收到停止位的中间时刻由内部硬件置位，即RI=1，向主机请求中断，响应中断后必须由软件复位。
- PCON：C/T置0，定时器模式；M1置0，M0置1，选择16位定时器
- TH0、TL0为计数单元

#### 串口中断

- 串口发送数据时，只需设置串口对应寄存器的值，设置对应模式。串口接收数据时，由于无法预测什么时候对方发数据，因此需要开启串口中断。每当接收到数据时，在串口中断里处理数据。
- 同一个函数不能同时出现在主函数的循环和中断函数中，否则会导致函数的重录，对函数的执行造成冲突
- 中断函数要用的时候要放在主函数下边

#### 数据显示模式

- HEX模式/十六进制模式/二进制模式：以原始数据的形式显示
- 文本模式/字符模式：以原始数据编码后的形式显示
- 参考ASCII码表：
- ![image-20241114232728127](image/image-20241114232728127.png)

### LED点阵屏

![image-20250126191304708](image/image-20250126191304708.png)

![image-20250126191323898](image/image-20250126191323898.png)

开发板上点阵屏的引脚对应关系

![image-20250126191646995](image/image-20250126191646995.png)

![image-20250126192110294](image/image-20250126192110294.png)

![image-20250126192428613](image/image-20250126192428613.png)

由图可知，点阵屏的八个高电平引脚由74HC595接入，八个低电平引脚由单片机接入。因而单片机引脚输出低电平时，对应的LED点亮，符合单片机引脚弱上拉输出的特性。

OE为output enable，即输出使能，同时OE上面有一横说明低电平有效，因此JOE那里要把跳线帽接到GND。RCLK为寄存器时钟引脚，SRCLR为串行清空引脚，SRCLK为串行时钟引脚，SER为数据输入引脚。QA~QH为八个输出引脚，QH'用于多片级联，与下一个74HC595的SER引脚相连，从而做到拓展IO口输出。

#### 74HC595特性

![image-20250127102031161](image/image-20250127102031161.png)

串行输入为1位1位输入，并行输出为8位同时输出。左边的9位空间为移位寄存器，右边为输出缓冲区。

##### 工作原理

串行时钟引脚SERCLK每接收到一个上升沿，SER的数据就在移位寄存器往下进一位。若寄存器时钟引脚有上升沿，则同时把八位数据移到输出缓冲区，此时QA~QH的输出即为输出缓冲区的内容。QH'是用于与下一片级联，QH被移出到QH‘的数据作为下一片74HC595的输入。

每次调用74HC595前都要进行初始化，即把SERCLK、RCLK清零；

注意：多片74HC595的串行时钟引脚和寄存器时钟引脚都各自相连在一起

C51的SFR、Sbit

- ![image-20250127150102551](image/image-20250127150102551.png)

疑惑点：P0的地址是0x80H，P0.0-P0.7分别是0x80H-0x87H，这些和其他特殊功能寄存器的地址不是冲突了吗，不会相互影响咩

注意：点阵屏和数码管一样都需要消影。

在设置特定引脚名称的时候，可以利用sbit来设置，对应的引脚用Pn^n（引脚号，也就是Pnn，例：P0.1、P3.2之类的）来表示

```c
sbit RCK = P3^5;
```

### AT24C02(I2C)

#### 存储器介绍

##### 易失性存储器/RAM(随机存储器)

数据存储速度快，会掉电丢失，用于程序运行时数据的高速存储

SRAM（静态 static RAM）本质是个D触发器，存储容量较小，造价高

DRAM（动态 dynamic RAM）本质是电容，通电即可存储电荷，但是因为会漏电，要配备扫描电路，每次扫描补充电荷。高速缓存Cache，即电脑的内存条就是这个。

##### 非易失性存储器/ROM(只读存储器)

数据存储速度慢，但是数据掉电不丢失，当程序运行完毕后将想保留的数据存入只读存储器

E2PROM（电可擦除可编程ROM）

Flash（闪存）

硬盘、软盘等

![image-20250128223008472](image/image-20250128223008472.png)

存储器的简化模型，存储器具有数据总线与地址总线，每次只能选取一条地址线传输数据。地址总线的选取又要搭配一个译码器，将八位并行二进制输入转化为串行十六进制数据。

##### IIC 总线（IIC BUS）

![image-20250130134931039](image/image-20250130134931039.png)

IIC通信双方只能用一根数据线进行数据传输，也就是分时使用一根数据线传输数据。由于IIC有公共时钟线，因此不用像串口要通信双方各自确定好通信频率。

此外，常见的IIC协议模块有OLED显示屏、MPU6050陀螺仪。

![image-20250131103554339](image/image-20250131103554339.png)

右边的是开漏输出，引脚浮空等于引脚在设备内部什么都没接，引脚上的电平是总线给予的高电平1，但是该高电平完全没有驱动能力，在iic中体现为CPU与总线上连接的设备通信断开。**开漏输出下，IIC总线存在线与，任何一个引脚为低电平都能把整条线电平拉低**。因此开漏输出在iic中起到CPU与总线上某一设备通信时，避免其他设备干扰的作用。

##### IIC时序结构

- 起始条件与终止条件

![image-20250131143856311](image/image-20250131143856311.png)

也就是在IIC时钟线SCL高电平时，SDA有对应时序变化，分别为起始条件与终止条件。蓝色的S为start，红色的P为stop。

- 发送一个字节

![image-20250131144350650](image/image-20250131144350650.png)

SDA处的两根线是指时序可能的情况，只是列举了两种情况。

**注意：数据传输时，SCL为低电平不变，SDA可以更改数据线上的电平。数据读取时，SCL为高电平，此时SDA上的数据不能改变。否则将会视为触发了起始条件或者停止条件，会产生错误。**

数据总线交叉处代表进行主机将数据传输到SDA，此时SCL为低电平。当SCL为高电平时，从机自动读取SDA上的电平数据，此时SDA不能发生电平变换。

绿色S（BYTE）代表发送一个字节

- 接收一个字节

![image-20250131142413891](image/image-20250131142413891.png)

主机在接收之前需要释放SDA，也就是将SDA置一，相当于之前小人将杆子松开，放回到高电平，将控制权交给从机，这样其他从机才能操作杆子。

紫色R（BYTE）代表接收一个字节

- 发送应答与接收应答

![image-20250131145405276](image/image-20250131145405276.png)

由于IIC总线是带有数据应答的通信协议，因此当主机发送完数据后需要释放SDA，使从机发送一位数据的接收应答给主机。**主机释放SDA的原因既包括把控制权交给从机，也有当从机不存在的情况自动表示不应答。**

当主机接收完从机的数据后，需要发送一位数据的发送应答给从机。数据0表示应答，数据1表示非应答。

ACK（acknowledge）为通信中的确认符，SA为sent ACK，RA为read ACK。

##### IIC数据帧

- 发送一帧数据

![image-20250131214431523](image/image-20250131214431523.png)

发送数据帧的格式在IIC协议中被设定为在S（start）后，第一个字节的数据一定是从机地址+写标志位（**前七位为从机地址，不同设备的地址不一样，设备地址应该在购买时有说明，最后一位为写标志位，写标志位为0**），发送完毕后从机应答，则后续可正常向从机发送数据。

发送完最后一个字节的数据后，从机应答，然后结束。

- 接收一帧数据

![image-20250131215116576](image/image-20250131215116576.png)

接收数据帧的格式在IIC中被设定为在S（start）后，第一个字节的数据一定是从机地址+读标志位（**前七位为从机地址，不同设备的地址不一样，设备地址应该在购买时有说明，最后一位为读标志位，读标志位为1**），接收完毕后主机应答，则后续可正常向从机发送数据。

- 先发送再接收数据帧（复合格式）

![image-20250131221354097](image/image-20250131221354097.png)

用于指定主机发送的需求（老师提问小明几个问题），从机根据需求把数据发送给主机，主机接收（小明按照问题回答答案，老师应答）。

所以在发送数据帧后不用加P（stop），直接把接收数据帧加上就行。

- AT24C02数据帧（适用于51单片机上存储芯片，其实适用于大部分iic协议模块）

  - 字节写

  在S后边三个字节分别为从机地址+写标志、字地址（从机存储器中要被主机写入数据的地址）、主机要写入的数据

  - 随机读

  在发送数据帧中的两个字节分别为，从机地址+写标志、字地址（从机存储器中要被主机读出数据的地址）。在接收数据帧中的两个字节分别为从机地址+读标志、从机被读出的数据

![image-20250131223815564](image/image-20250131223815564.png)

AT24C02的固定地址为1010，也就是从机地址的高四位为固定地址，低四位的前三位为用户定义的设备地址。每种设备的都有其公司定义的固定地址。

![image-20250131224925459](image/image-20250131224925459.png)

数据手册上的字节写与随机读数据帧的时序图，写标志位为0，读标志位为1

AT24C02芯片数据手册上，其写周期最大时间为5ms，也就是每次主机把数据写入ROM都要最少delay5ms，ROM内部硬件操作需要这些时间。连续读多个字节是不用delay的，只有写入的时候才要。

![image-20250201160818669](image/image-20250201160818669.png)

![image-20250201161043336](image/image-20250201161043336.png)

可能是在写序列所有数据传输完成，然后从机应答后，需要有5ms的时间给AT24C02把数据写入存储器

### PWM

#### 直流电机介绍

![image-20250204221742680](image/image-20250204221742680.png)

- 步进电机，定子为一圈电磁铁，转子为永磁体。当电机要旋转时，给圆周直径上的一对磁铁通电，也就是圆型脉冲加于磁铁上，转子会被磁铁吸引从而旋转。转子旋转的快慢取决于程序编码的通电时间，可以看作控制磁铁通电的换向
  - ![image-20250204222100830](image/image-20250204222100830.png)
- 舵机，由直流电机、旋转臂与控制板组成，引出三条线，5V输入、GND、编码线，通过控制电平的持续时间控制旋转臂的位置，比如说通电5ms臂停在0°，10ms停在90°，15ms停留在180°。
- 带编码器和减速器的直流电机，编码器用于电机测速，电机在使用过程中常常被希望恒速转动，并且带载和空载速度也不一样，电压不同也会影响电机速度。因此，可以利用编码器加上控制算法（PID、滑膜、自适应、模糊、鲁棒控制）来控制电机恒速转动。

##### 同步电机与异步电机

[同步电机与异步电机的区别](https://blog.csdn.net/weixin_40162095/article/details/110733244?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522937debf32cd5af4856ef2e955c7d5fcf%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=937debf32cd5af4856ef2e955c7d5fcf&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-110733244-null-null.142^v101^pc_search_result_base5&utm_term=%E5%90%8C%E6%AD%A5%E7%94%B5%E6%9C%BA%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%94%B5%E6%9C%BA&spm=1018.2226.3001.4187)

此外电机也分为同步电机与异步电机

##### 电机驱动

![image-20250205122552003](image/image-20250205122552003.png)

电机驱动电路有如下两种：

- 大功率器件直接驱动
  - 以上方的PNP三极管作为开关，在基极输入低电平，电路通电，电机转动，但是**只能单向转动**。基极输入高电平，电路断开，电机停止转动。由于**电机内部有感性元件，也就是电感**，当断电后会阻碍电流的消失，保证电流值不会突变。因此如果不加二极管让电机回路导通逐渐减小感应电流，电机上会产生感应电压击穿三极管。
- H桥驱动
  - 电机两个方向旋转分别给左上与右下、左下与右上输入高低电平通电。由于使得电机可以正反向转动，因此该电路无法接续流二极管，则要求电路中的三极管耐压性高。

##### PWM介绍

- PWM（Pulse Width Modulation）即脉冲宽度调制，**在具有惯性的系统中**（电机、LED）中可以**通过一系列脉冲的宽度进行调制**，来等效地获得所需要的模拟参量，常应用于电机控速、开关电源等领域
- PWM重要参数：
  - 频率=1/Ts，占空比=Ton/Ts，精度=占空比变化步距
  - ![image-20250205131703712](image/image-20250205131703712.png)
  - Ts为脉冲宽度调制周期，也就是从高电平变换到低电平的持续时间。频率为脉冲宽度调制频率，频率越高，第一幅图所模拟出来的电机速度模拟曲线越接近正弦波曲线。Ts一般在脉冲宽度调制过程中是保持一致的，不会变化，但就算变化了也可以进行脉冲宽度调制
  - Ton为打开时间，也就是高电平持续时间，占空比为高电平持续时间占Ts的百分比，占空比越大，电机转速越快。
  - 若占空比可以从1%变换到2%、3%、4%...，称精度为1%。若占空比可以从1%变换到1.1%，1.2%、1.3%、1.4%...，称精度为0.1%。也就是精度越高，可以使得占空比调节的越细致，电机速度变化的更加精确。

##### 定时器产生PWM方法

![image-20250205155547549](image/image-20250205155547549.png)

可在定时器中断服务函数中设定计数器与比较值，当计数器小于设定值时，输出0；当计数器大于等于设定值时，输出1；

疑惑：为什么定时器里边加按键检测和数码管扫描会影响电机驱动？课程里是把按键和数码管直接放在主循环里延时

测试了一下，带定时器和不带定时器的效果几乎一致，都是第一档占空比为50%时需要拨一下电机扇叶才能转动，是电机线的问题？

### AD/DA

#### AD/DA介绍

- AD（Analog to Digital）:模拟-数字转换，将模拟信号转换为计算机可操作的数字信号，比如单片机是只能操作数字信号，如果输入个2.5V的模拟电压信号要怎么转换为可以操作的数字信号。51板子上的ADC模块其实就是AD转换器
- DA（Digital to Analog）:数字-模拟转换，将计算机输出的数字信号转换为模拟信号。比如如何将单片机输出的高低电平转换为具体的模拟电压信号，是2.5V还是5V
- 总而言之就是AD可以把电压变成内存的数据，DA可以把内存的数据变成电压
- 常见的数模转换与模数转换模块如下：
  - ![image-20250206170134520](image/image-20250206170134520.png)
  - 有压力传感器、喇叭等等

#### 硬件电路模型

- ![image-20250207092039337](image/image-20250207092039337.png)
- 也就是0 ~ 5V的模拟电压输入对应0 ~ 255的八位无符号数字量输出，也可以设置转化为十六位数字量输出，可以得到更精细的模拟量值
- 这里的串口不是串口通信的串口，并口可以把八位数据拆解为一根线一位，八位数据同时发送，串口只能一位一位的发送。
- DA接低通滤波电容就可以输出连续的模拟信号？

#### 硬件电路

![image-20250207103012788](image/image-20250207103012788.png)

- 可以使用PCF8591芯片，也是AD/DA芯片，比较常用

#### 运算放大器

![image-20250207103726607](image/image-20250207103726607.png)

- 之前在matlab里的比例放大器和积分器

#### 运放电路

![image-20250207104032712](image/image-20250207104032712.png)

#### DA原理

![image-20250207104644899](image/image-20250207104644899.png)

![image-20250207104733413](image/image-20250207104733413.png)

- 滤波器下端接地就是低通滤波器，上端接正极输入就是高通滤波器，两组低通滤波器就是二阶低通滤波器
- 由于PWM输出是包括直流分量和交流分量的，低通滤波器的截止频率较低，交流分量全被滤除，剩下的只有直流分量。根据PWM输出的直流分量和占空比相乘得出输出的连续模拟电压量

#### AD原理

![image-20250207112155647](image/image-20250207112155647.png)

#### AD/DA性能指标

![image-20250207112256174](image/image-20250207112256174.png)

- 比较重要的就是分辨率，相当于数字量一个单位代表多少小数位的电压值
- 转换速度是指模拟量、数字量采样和输出频率，如果是针对高速信号的采样和输出要注意AD/DA的转换速度

#### XPT2046

![image-20250207113606117](image/image-20250207113606117.png)

XPT2046时序（其实也是SPI通讯协议）

![image-20250207114001932](image/image-20250207114001932.png)

- SPI协议有四个端口，分别是CS片选、DCLK时钟线、DIN输入、DOUT输出。DIN在其他芯片也会被称作MISO，为主设备输入，从设备输出。DOUT被称作MOSI，为主设备输出，从设备输入。
- 注意：DIN和DOUT是对于从设备的DIN，也就是主体是从设备，MISO中的主设备是从设备。
- 因此通信的时序是首先CS片选，从设备向主设备传递被选择的信号，接着是从设备上升沿读入，下降沿输出
- 开始时先接收初始的设置帧，S为状态控制字，A2、A1、A0控制哪路，也就是多路选择。MODE有多种模式，8位、12位
- 其他三位为控制位，单端模式、差分模式，参考电压等等。
- 模式为12位时，主机端要读入16位数据，16位的后四位用0来填充，取前12位可得到正常的数据。
- **根据视频代码来看，每次接收XPT2046传递的数据都要主机先发送一次控制帧。**

注意：使用每个模块都要看对应的数字时序图，且引脚值只能作为标志位来用，不能拿来当作数值运算。

![image-20250210114517323](image/image-20250210114517323.png)

SPI的时序图，按照时序规范，设置电平保持时间，图中大部分时间都为ns，而51单片机的一个机器周期为1us，因此基本满足SPI时序规范。

![image-20250210132408136](image/image-20250210132408136.png)

![image-20250210132436383](image/image-20250210132436383.png)

